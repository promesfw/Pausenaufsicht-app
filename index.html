// VERBESSERTE Funktion für gleichmäßige intervall-basierte Einsatzplanung
        function generateDayScheduleWithIntervals(day, dayIndex, dayMembers, allWeeks) {
            // Zähle zunächst alle Arbeitswochen
            const totalWorkWeeks = allWeeks.filter(({ week }) => {
                const dayKey = `${week}-${dayIndex + 1}`;
                return !appData.freeDays.includes(dayKey);
            }).length;

            // Berechne Soll-Einsätze pro Person
            const targetAssignments = {};
            let totalTargetSlots = 0;
            
            dayMembers.forEach(member => {
                const expectedDuties = Math.floor(totalWorkWeeks / member.interval);
                targetAssignments[member.name] = expectedDuties;
                totalTargetSlots += expectedDuties;
            });

            // Tracking für tatsächliche Einsätze
            const actualAssignments = {};
            const lastAssigned = {};
            dayMembers.forEach(member => {
                actualAssignments[member.name] = 0;
                lastAssigned[member.name] = -999;
            });

            let workWeek = 0;

            allWeeks.forEach(({ week }) => {
                const dayKey = `${week}-${dayIndex + 1}`;

                // Freie Tage überspringen
                if (appData.freeDays.includes(dayKey)) {
                    return;
                }

                let selectedMembers = [];

                // SCHRITT 1: Teilzeit-Personen prüfen (interval > 1)
                const teilzeitPersonen = dayMembers.filter(m => m.interval > 1);
                teilzeitPersonen.forEach(member => {
                    const wochenSeitLetztemEinsatz = workWeek - lastAssigned[member.name];
                    const istDran = wochenSeitLetztemEinsatz >= member.interval;
                    const hatNochBedarf = actualAssignments[member.name] < targetAssignments[member.name];
                    
                    if (istDran && hatNochBedarf && selectedMembers.length < appData.teamSize) {
                        selectedMembers.push(member);
                        lastAssigned[member.name] = workWeek;
                        actualAssignments[member.name]++;
                    }
                });

                // SCHRITT 2: Vollzeit-Personen nach Bedarf sortieren
                const vollzeitPersonen = dayMembers.filter(m => m.interval === 1);
                
                // Sortiere nach: 1. Bedarf (wer hat weniger als Soll), 2. längste Pause
                vollzeitPersonen.sort((a, b) => {
                    const bedarfA = targetAssignments[a.name] - actualAssignments[a.name];
                    const bedarfB = targetAssignments[b.name] - actualAssignments[b.name];
                    
                    // Zuerst nach Bedarf (höherer Bedarf = niedrigere Position)
                    if (bedarfA !== bedarfB) {
                        return bedarfB - bedarfA;
                    }
                    
                    // Bei gleichem Bedarf: längste Pause zuerst
                    return lastAssigned[a.name] - lastAssigned[b.name];
                });
                
                // Fülle restliche Plätze mit Vollzeit-Personen
                vollzeitPersonen.forEach(member => {
                    if (selectedMembers.length < appData.teamSize) {
                        selectedMembers.push(member);
                        lastAssigned[member.name] = workWeek;
                        actualAssignments[member.name]++;
                    }
                });

                // Falls immer noch zu wenige Leute: Fülle mit allen verfügbaren auf
                if (selectedMembers.length < appData.teamSize) {
                    const remainingMembers = dayMembers.filter(m => 
                        !selectedMembers.some(s => s.name === m.name)
                    ).sort((a, b) => lastAssigned[a.name] - lastAssigned[b.name]);
                    
                    remainingMembers.forEach(member => {
                        if (selectedMembers.length < appData.teamSize) {
                            selectedMembers.push(member);
                            lastAssigned[member.name] = workWeek;
                            actualAssignments[member.name]++;
                        }
                    });
                }

                // Einsätze speichern
                appData.schedule[dayKey] = selectedMembers.map(m => m.name);

                workWeek++;
            });
        }
